# Multi-language Checklist

Source: https://processwire.com/docs/multi-language-support/
Source: https://processwire.com/docs/multi-language-support/code-i18n/
Source: https://processwire.com/docs/multi-language-support/multi-language-fields/
Source: https://processwire.com/docs/multi-language-support/multi-language-urls/
Source: https://processwire.com/docs/multi-language-support/multi-language-modules/

## Checklist

- Multi language support with ProcessWire CMS: Multi-language page names (URLs) and multi-language text fields make developing a multilingual site as easy as developing a single language site. ProcessWire's multi-language support includes a full gettext-style translation system, but with the translation tools built into the CMS, and without actually using gettext. You can also install (or create) alternate language packs for the admin side of ProcessWire.Multi-language support is installed with core modules available in the admin: Modules > Language > Language Support. If you just want to install alternate language packs, then all you need is the base Language Support module. If you want to support multi-language fields in your own site, then you should also install the Language Support Fields module. We also recommend installing Language Support Page Names module for multi-language URLs. Code i18nThis page provides detailed documentation on everything you need to know to make your template files or modules translatable…Learn more →Multi-language fieldsHere we look in detail at multi-language fields and language-alternate fields, as well as how to use them. Also includes a video…Learn more →Multi-language URLsMulti-language URLs and page names enable you to maintain different/translated URLs for each page, based on the language. It also…Learn more →Language PacksLanguage packs for use with the ProcessWire admin.Learn more →Multi-Language Support ForumA place to get support and chat about multi-language capabilities in ProcessWire.Learn more →Hreflang tag generatorHreflang tag generator for multi-language websites. Select a language and optionally a country to generate the hreflang tag.Learn more →Creating multi-language modulesIf you are a module developer, you might want to bundle multi-language translations with your module. This page covers all the…Learn more →
- PHP Internationalization (i18n) and multi-language tools in ProcessWire CMS: This page provides detailed documentation on everything you need to know to make your template files or modules translatable using ProcessWire's translation tools. This will primarily be of interest to those that are wanting to make static text in their own template files or modules translatable using ProcessWire's translation tools. ProcessWire uses a GNU gettext-like system for managing language translation of strings in your code (without actually using gettext).Translatable stringsMarking strings for translationSyntax inside a class vs. syntax outside of a classPlaceholdersPluralsContextComment descriptionsComment notesTranslation rulesTranslation function calls must be on one line and in one pair of quotesThere may only be one translation function call per lineEmpty stringsBest practicesTechnical detailsUsing TextdomainsDemonstration VideoBelow is a brief video demonstrating how simple it is to use ProcessWire's language translation tools in your own templates (switch to 720p and the full screen version to see it better):Translatable stringsIn order to make a string translatable in your template or module code, you just have to wrap the original string in a $this->_() or __() function call:$out = $this->_("Live long and prosper"); // syntax within a class$out = __("Live long and prosper!"); // syntax outside of a classMarking strings for translationThe strings for translation are wrapped in a call to one of a set of special functions. The most commonly used ones are $this->_() and __(). These functions just returns the translation of their argument:echo "<h2>" . $this->_('Site Information') . "</h2>";Syntax inside a class vs. syntax outside of a classIn ProcessWire, the functions __() and $this->_() are equivalent, but __() will work in all contexts while $this->_() will only work within the context of a class. So why have $this->_() at all? Because it has a speed advantage that can only be realized within the context of a class. As a result, the following rules apply:When your translation needs occur outside of a class–such as in a template file–you must use the __('string') function call.When your translation needs occur within a Processwire class–such as in a plugin module–it is preferable (though not required) to use $this->_('string').The rules above also apply to the other translation functions outlined later in this page.PlaceholdersLets say that you needed to output a string like this:echo "Created $count pages."Perhaps your first thought is to try this:echo __("Created $count pages.");It won't work! Strings for translation are extracted from the ProcessWire PHP files, so people performing translation will see the phrase: Created $count pages… However in ProcessWire, the __() function will be called with an argument like Created 3 pages. and ProcessWire won't find a suitable translation and will return its argument: Created 3 pages… regardless of how many pages there actually were. Meaning, it isn't translated correctly.The solution is to use the printf family of functions. Especially helpful are printf and sprintf. Here is what the right solution to the page count problem will look like:printf(__("Created %d pages."), $count);Or, if you are building output into a variable (like $out), you'd use sprintf:$out = sprintf(__("Created %d pages."), $count);Notice that the string for translation is just the template “Created %d pages.”, which is the same both in the source and at run-time.If you have more than one placeholder in a string, it is recommended that you use argument swapping. In this case, single quotes (') are mandatory : double quotes (") will tell php to interpret the “$s” as the $s variable, which is not what we want.$out = sprintf(__('Your city is %1$s, and your zip code is %2$s.'), $city, $zipcode);Here the zip code is being displayed after the city name. In some languages displaying the zip code and city in opposite order would be more appropriate. Using %s prefix in the above example, allows for such a case. A translation can thereby be written:$out = sprintf(__('Your zip code is %2$s, and your city is %1$s.'), $city, $zipcode);PluralsLet's get back to the 'created pages' example: sprintf(__("Created %d pages."), $count);. What if we create only 1 page? The output will be: “Created 1 pages.”, which is definitely not correct English, and would certainly be incorrect for many other languages as well.In ProcessWire you can use the _n() or $this->_n() function.$out = sprintf(_n("Created %d page.", "Created %d pages.", $count), $count);_n() and $this->_n() accept 3 arguments:singular — the singular form of the stringplural — the plural form of the stringcount — the number of objects, which will determine if the singular or the plural form to be returned (there are languages, which have far more than 2 forms)The return value of the functions is the correct translated form, corresponding to the given count.ContextSometimes one term is used in several contexts and although it is one and the same word in English it has to be translated differently in other languages. For example the word Post can be used both as a verb (Click here to post your comment) and as a noun (Edit this post). In such cases the _x() or $this->_x() function should be used. It is similar to __(), but it has an additional second argument–the context:$label = _x('Comment', 'noun'); // or $this->_x('Comment', 'noun') in a class ... // some other place in the code echo _x('Comment', 'column name');Using this method in both cases we will get the string Comment for the original version, but the translators will see two Comment strings for translation, each in the different contexts.To summarize contexts, you should use the _x() or $this->_x() functions when two or more identical translatable strings will appear in more then one place in the same file.Comment descriptionsDo you think translators will know how to translate a string like: __('g:i:s a')? In this case you can add a clarifying comment in the source code. The comment must begin with // and be on the same line as the translation function call. Here is an example:$date = __('g:i:s a'); // Date string in PHP date() formatIn this way you can write a personal message to the translators, so that they know how to deal with the string. It is also recommended that you use comment descriptions in long translatable strings (i.e. those that are more than a sentence) so that you can summarize what it is for. The translator will be provided with the string to translate either way, so it is always good to use comment descriptions any time you think they might be helpful.Comment notesYou can also use secondary comment descriptions, called "notes". These appear as secondary notes below the input field the translator is working with. This is a way to provide additional details that you may want separated from the main comment description. This is also what ProcessWire uses to identify context or plurals to the translators (which it does automatically). Here is an example of how you might use notes:echo __("Welcome Guest"); // Headline for guest user // Keep it short (2-3 words)Translation rulesProcessWire's file translation parser works very much like the gettext parser in that it pulls the strings directly from the PHP files (outside of program execution), rather than identifying them at runtime. This is necessary because it is simply not possible to identify every translatable string at runtime. It would require every scenario to play out at execution (i.e. every error message, every success message, etc. in the same request). Given that, ProcessWire has to be able to identify your translatable strings directly in the PHP source code of your files. The format must be consistent and well-formed, as outlined below. Note that these rules may vary somewhat from those of WordPress and other gettext-implementations.Translation function calls must be on one line and in one pair of quotesA translation function call must exist on a single line and be within a single pair of quotes. Here are examples that will NOT work:$out = __("Something " . "and something else"); // bad$out = __("Now is the time for all good men " . // bad "to come to the aid of their party.");And here are examples that WILL work:$out = __("Something and something else"); // good$out = __("It's time for you \nto get to the party."); // goodNote the "\n" between the words "you" and "to" above. It is okay to include a PHP carriage return character in your strings like this if you need it. What's not okay is to have an actual line break in your code.To reiterate the above examples: if you have a long string of text that you are sending to a translation function, you need to keep it all on one line. Embrace horizontal scrolling in your code editor. There may only be one translation function call per lineYour translation function calls should be limited to one per line. The parser will not recognize more than one translation call per line so any additional calls after the first will be ignored by the parser. This is to ensure that you can adequately use comment descriptions (as mentioned earlier), as well as to ensure consistent and readable code. Here is an example that will NOT work:$out = __("Something") . " " . __("and something else"); // badAnd here are examples that WILL work:$out = __("Something") . " " . // good __("and something else");…or…$a = __("Something"); // good $b = __("and something else"); $out = "$a $b";Empty stringsDon't try to internationalize an empty string. It doesn't make any sense, because the translators won't see any context.Best practicesWhile ProcessWire doesn't use gettext, it is based on many of the same conventions and what applies for gettext generally applies for translation in ProcessWire. Below is a summary of best practices from the gettext manual and this page.Decent English style—minimize slang and abbreviations.Entire sentences—in most languages word order is different than that in English.Split at paragraphs—merge related sentences, but do not include whole page of text in one string.Use format strings instead of string concatenation: sprintf(__('Replace %s with %s'), $a, $b); is always better than __('Replace ') . $a . __(' with ') . $b;Avoid markup and unusual control characters—do not include tags that surround your text and do not leave URLs for translation, unless they could have version in another language.Do not leave leading or trailing whitespace in a translatable phrase.Keep your translation phrases on 1 line and between 1 pair of quotes.Use only 1 translation function call per line in your source code.Use $this->_('string') in your class files, and __('string') everywhere else.Technical detailsBelow are some additional technical details that may be of interest to some, but are not required reading.Using TextdomainsIf you've worked with gettext before, you may be familiar with the term "textdomain", which refers to a group of related translations. Textdomains are used to ensure that only the necessary translations are kept in memory at the same time, and that there aren't namespace collisions of unrelated translations. While ProcessWire does not use gettext, it does use textdomains, though in a little bit different way.In ProcessWire, each PHP file is considered it's own textdomain and the textdomain is nothing more than the filename (including path) from the root of the ProcessWire installation. The textdomain is not loaded by ProcessWire until a function call from a given PHP file requests a translation for a phrase. The textdomain consists of all translation phrases for the current language in one PHP file, and textdomains are internally stored in JSON files by ProcessWire.The developer using translation function calls does not have to think about textdomains, as it is something that ProcessWire figures out behind the scenes. However, if a developer does want to override the textdomain from the curent file for a given translation, they can do so by specifying the PHP filename (including path) as the second argument to a __() call, like this:echo __('Save', '/site/templates/common.php');You will see an example of this in ProcessWire's admin theme in the file /wire/templates-admin/topnav.inc:$title = __($title, '/wire/templates-admin/default.php');We do that in the default admin theme because we want to pull translations from default.php without keeping duplicate copies of translatable phrases in topnav.inc. You can see we're actually using $title rather than a static string in the function call above. We're doing that because we only need the translation capability of the __() function, which ultimately doesn't care if you give it a dynamic or static string. We've setup some predefined translations in default.php that we know are expected, like 'Pages', 'Setup', etc., and that's what is being translated in the above function call.The __() function will also accept an actual object instance as a textdomain as well. It will figure out what file it came from on it's own. So if you know that there is a translatable phrase in the $pages API object that you want to make use of, you can put your phrase in the context of the $pages textdomain (/wire/core/Pages.php) just like this:echo __('Page saved', $pages);Note that the above is a contrived example used for demonstration purposes only, as $pages doesn't actually have any translatable phrases in it
- Multi-language CMS fields in ProcessWire: Here we look in detail at multi-language fields and language-alternate fields, as well as how to use them. Also includes a video overview and examples of how to use language fields to create full multi-language websites.ProcessWire supports the use of multi-language fields and language-alternate fields. A multi-language field is a single field that supports multiple languages, and these are typically text-based fields. Language-alternate fields are separate fields where the value of one can substitute for another, when the user's language justifies it. Below is a short video that demonstrates the use of both.Multi-language fieldsLanguage alternate fieldsHow language fields work from the $pages APIGetting and setting language-specific values in the APIMulti-language field valuesLanguage alternate field valuesThis is an old video, but all the concepts still apply in current versions of ProcessWire. Getting startedHow to installTo use multi-language fields or language-alternate fields, you must first install the "Language Support - Fields" module, included with ProcessWire 2.2 or newer. To do this, click "install" for "Language Support - Fields" from the Modules menu.When and where to use language fieldsLanguage fields (whether multi-language or language-alternate) enable your site's template files to deal with just one field name while the value is affected by the current user's language. In fact, your template files don't even need to know about languages. This makes it a relatively simple matter to support languages in existing sites.In order to present your site's content in a different language using language fields, the current user's language has to be set to the one you want the site to display in. This is a simple matter if you are dealing with users that can log-in, because they can set their language from their profile. However, we are assuming you want to use language fields for the purpose of having multi-language versions of your site available to anonymous visitors. There are a large number of approaches you could take. See the numerous examples on this page for how multi-language fields can be used to produce a multi-language website.Multi-language fieldsProcessWire 2.2 includes 3 new fieldtypes that support multiple languages:TextLanguage – single line text fieldTextareaLanguage – multi-line text or rich-text (TinyMCE) fieldPageTitleLanguage – special text field to be used with page titles onlyThese 3 fieldtypes correspond to the standard text fieldtypes already included in ProcessWire: Text, Textarea and PageTitle. When you convert a field to the multi-language version (i.e. convert a Textarea to a TextareaLanguage) the field now has inputs for every installed language in your system. If an input is left blank for any language, then the default language is substituted at runtime.Converting an existing field to multi-languageTo convert an existing field to a multi-language field, it must be a Text, Textarea or PageTitle field. Edit the field settings in Setup > Fields > Your Field. Change the "Type" to be: TextLanguage, TextareaLanguage or PageTitleLanguage. Because this change involves adding new columns to the field's database table, it will ask you to confirm the schema change. While this is a safe process, any time something modifies existing database tables, it's a good idea to make sure you have a backup of your database. When ready, confirm the change, and your field will now support all languages installed in the system. Should you want to convert back, repeat the same process but choose the non multi-language fieldtype instead.Please note: when converting to or from a multi-language field, some of your field settings can be lost. For instance, if you are converting a textarea field that uses TinyMCE for input, you will have to reconfigure these settings after converting to or from a multi-language field. Creating a new multi-language fieldTo create a new multi-language field, all you need to do is go to Setup > Fields > Add New. When it asks you to select a field type, choose either TextLanguage or TextareaLanguage.Language-alternate fieldsLanguage-alternate fields allow for the value of one field to replace the value of another when the user's language is something other than the default. Unlike multi-language fields, language-alternate fields are actually separate fields that you create on your own. ProcessWire identifies them based on the name you give them. The name is a combination of an existing field in the system combined with the language name.Creating a language-alternate fieldIf you wanted a Dutch version of your "body" field, you would name your new field "body_dutch". Meaning, a language alternate field should be named with the original field name, followed by an underscore and the language name.Assuming you have a language installed named "dutch" and the current user's language is Dutch, then ProcessWire will return $page->body_dutch when you access $page->body. However, if $page->body_dutch is empty, then it will return $page->body instead.Unlike multi-language fields, language alternate fields can be used with any type of field.How language fields work from the $pages APIWhether using multi-language fields or language-alternate fields, when a user's language is something other than the default, then the value of the field reflects the language-specific value, if it is available. If it is not available, then the default language version is substituted. Likewise, any API calls using selectors that include the field, will match pages that contain the term in either the current user's language, OR the default language.ExampleWe will assume that the current user's language is Dutch and that this is a language installed in the system. We will also assume that the field "body" is a multi-language textarea field. Because the user's current language is Dutch, the following API call matches any pages that contain the phrase "welkom vrienden" (welcome friends) in the Dutch body field OR the default body field. If there are other languages installed, it does not attempt to search them.$results = $pages->find("body*=welkom vrienden");Lets now change the example and say that "body" was not a multi-language field, but it had a language-alternate field called "body_dutch". Because the user's current language is Dutch, the results of the above API call would be identical to when we were considering multi-language fields. Meaning, a search in the "body" field actually performs a search on "body_dutch" and "body" at the same time. Should you need to, you can also target just the language-alternate field by specifying it's name in the selector, i.e. "body_dutch" rather than "body".Getting and setting language values in the APIGetting values is no different from anywhere else in the API except that you'll be getting a value that is specific to the current user's language. As a result, if you wanted to get a value in some other language installed on your system, you would have to switch the current user's language:$language = $user->language; // save the user's language $user->language = $languages->get("french"); // change user to French echo $page->body; // output the French version of body $user->language = $language; // restore the user's languageThe value of a multi-language or language-alternate field is affected by the "outputFormatting" setting of a page. On the front-end of your site, outputFormatting is always turned on, unless you've turned it off. In other applications, like in the admin, or at the command line, outputFormatting may be off by default. The example above, and most of the documentation on this page assumes that outputFormatting is on. In cases where outputFormatting is off, the value of our language fields may be different. These differences are outlined below:Multi-language field valuesWhen outputFormatting is ON, the value of a multi-language field is a string (as it shows in most examples on this page). That string reflects the value from the current user's language. If the value is blank in the current user's language, the value from the default language will be there instead.However, when outputFormatting is OFF, the value of a multi-language field (like $page->body) will instead return an object of type LanguagesPageFieldValue, rather than a string. That object contains all of the translations available for the given field. If you access or typecast this object as a string, it will return the same thing as if outputFormatting was on. If you want to get or set the value of this field for another language, you can do the following:$page->of(false); // turn off outputFormatting (if it's not already) $dutch = $languages->get('dutch'); // get the language we want $body = $page->body->getLanguageValue($dutch); // get the unformatted value in DutchThis is very similar to what we did in an earlier example, except that we didn't have to change the current user's language, and we're dealing with a value that has not had any textformatters applied to it (which is exactly what you want if you need to modify and save it).Setting a multi-language field valueWhen you set the value of a multi-language field, it sets the value for the current user's language. So if the current user's language was Dutch, and we set the value of "body", it would set it for the Dutch version of body:$page->body = "welkom vrienden"; // sets it in DutchIf we change the user's language, and then set it again, it sets it in that user's language:$user->language = $languages->get("spanish"); $page->body = "Bienvenidos amigos"; // sets it in SpanishYou can also set the language-specific values without changing the current user's language by using the setLanguageValue() function. This is usually preferable when modifying the contents of multiple languages:$dutch = $languages->get("dutch"); // retrieve Dutch $spanish = $languages->get("spanish"); // retrive Spanish $page->of(false); // outputFormatting must be OFF $page->body->setLanguageValue($dutch, "Welkom vrienden"); // set in Dutch $page->body->setLanguageValue($spanish, "Bienvenidos amigos"); // set in Spanish $page->save(); // save the page with the new language valuesLanguage-alternate field valuesFor the following description, lets assume we have a field called "body" and another called "body_dutch", which is the Dutch alternate for body. The value of a language-alternate field is always a string, regardless of whether outputFormatting is on or off. But when outputFormatting is ON (as it is in most API usage), the value of "body" will be the value of the alternate field when the user's language justifies it. For instance, if the user's language is Dutch, and the value of $page->body_dutch is populated, then an access to $page->body will actually return the value from $page->body_dutch. But if $page->body_dutch is not populated, then the default, $page->body is returned.When outputFormatting is OFF, the language-alternate fields behave as if they were completely separate, unrelated fields. Meaning, $page->body will always return the value of $page->body (never substituting the value of $page->body_dutch).Regardless of whether outputFormatting is on or off, you can always access the language-specific alternate fields and expect that they will return the value in the language they signify. So regardless of what the current user's language is, $page->body_dutch will always return the Dutch version of body, and $page->body_spanish will always return the Spanish version. It is only $page->body that has it's value substituted with alternate language versions when outputFormatting is on.Setting a language-alternate field valueWhenever you set a language-alternate field value, languages are not a consideration–the fields perform exactly the same as if language support wasn't active. So if you set $page->body, it is always going to set it for the default language. If you set $page->body_dutch, it is always going to set it for Dutch. As a result, the behavior in this aspect is the same regardless of whether outputFormatting is on or off. But you would typically only set values to a page with outputFormatting OFF (assuming you were going to save it), so this distinction may not matter much in actual use. Given that, an example may be redundant, but here is one anyway:$page->of(false); // turn off outputFormatting $page->body = "Welcome friends"; // sets it in default language $page->body_dutch = "Welkom vrienden"; // sets it in Dutch $page->body_spanish = "Bienvenidos amigos"; // sets it in Spanish $page->save(); // save the page
- Multi-language URLs in ProcessWire CMS: Multi-language URLs and page names enable you to maintain different/translated URLs for each page, based on the language. It also lets you produce your site easily, as the language is determined automatically by the URL.ProcessWire takes care of all the work behind the scenes, and everything just works. Combined with multi-language fields, you can have a multi-language website with only a few clicks.OverviewExampleGetting startedGoing furtherImplementing a language switcherAPI additions and enhancementsWorking with pagination and/or URL segmentsImproving the multi-language UILanguage Field TabsQuestions and supportFormBuilder and ProCacheOverviewAs of ProcessWire 2.3.2 and newer (currently the dev branch on GitHub), we recommend installing the Language Support Page Names module, included with ProcessWire's core. This enables you to deliver a single page at different URLs, consistent with the language. Since the module can determine the language from the URL, that also means it can take care of determining and setting the language automatically. The end result is that you can write your site's template files without consideration of getting or setting the language. ProcessWire takes care of all the work behind the scenes, and everything "just works."ExampleTripsite is an excellent example of a large multi-language website (in 5 languages) using ProcessWire with multi-language page names and multi-language fields. For example, these URLs reflect the same page in ProcessWire, but are accessed at different language-specific URLs, and output content specific to the language represented by the URL:English: www.tripsite.com/bike-boat/Spanish: www.tripsite.com/es/bici-barco/We encourage you to browse this site further to see some of the possibilities with multi-language support.Getting startedMulti-language URLs / page names are best paired with multi-language fields. Meaning, we recommend installing both the Language Support Fields and Language Support Page Names modules together. In order to test things out properly, start with at least one multi-language text field (i.e. field of type: TextLanguage, TextareaLanguage or PageTitleLanguage), edit a page using it, and populate it with the same text in multiple languages. This probably goes without saying, but you should also have more than one language installed in your system before proceeding further.Once the Language Support Page Names module is installed, go and edit your homepage and click on the settings tab. For the URL Name, you should see multiple inputs, one for each language. These will represent the starting point of page URLs in each language. We recommend populating these with the same value as your language name (i.e. "es" for Spanish, "de" for German, "en" for English, etc.), though there is no requirement that they match up wit your language names. Some prefer to leave the "default" language page name blank, so that the URLs have no language segment at the beginning. Check the Active checkbox next to each language, so that the page is considered viewable in that language.Once you have populated these names for your homepage, save and view the page. Now access the page in your web browser at one of the other language names you populated, like /de/ or /es/. Your translated multi-language fields should reflect the text in the language you expect. Likewise, any static translations (if you are using them) should reflect the proper language as well. The value of $user->language has been set automatically by ProcessWire.That is literally all there is to it. Note that you didn't have to change anything about the code in your site's template files. Just a few clicks and you have a multi-language website.Please note that the URL for the default-language homepage is always your site's root URL, regardless of what you specify in the homepage name. This is intentional, as it's not desirable to have a homepage that produces a 404 or immediately performs a redirect to another URL. If populated, your homepage name for the default language is still applicable for the rest of the pages in your site. Going furtherThe strategy that we used above to specify the page name at the homepage can be applied to any page in your site. But it's also optional from this point forward. You can translate the name of every (or any) page, but you don't have to. If you leave the non-default page names blank, then the default-language value is used instead. However, you will need to have the Active checkbox checked for any pages that you want to be visible in other languages.One of the nice things about multi-language page names is that you don't have to do anything from the template-file side in order to detect or set the language. So there isn't really a lot to say about it until your needs get more specific. Below we try to cover some of the specific needs you may run into when building a multi-language site with multi-language page URLs/names.Implementing a language switcherWhen visiting Tripsite, note that every page has one or more language switchers, enabling the user to view the same page in other languages. Here are a couple of approaches you can use to do the same.First lets say you wanted to generate a list that linked to the page in all other languages it is available in (excluding the current language). Here's what the end result might look like (taken from this page):And here's the code to implement it:// remember what language is set to $savedLanguage = $user->language; foreach($languages as $language) { // if user is already viewing the page in this language, skip it if($language->id == $savedLanguage->id) continue; // if this page isn't viewable (active) for the language, skip it if(!$page->viewable($language)) continue; // set the user's language, so that the $page->url and any other // fields we access from it will be reflective of the $language $user->language = $language; // output a link to this page in the other language echo "<li><a href='$page->url'>$language->title: $page->title</a></li>"; } // restore the original language setting $user->language = $savedLanguage;As an alternative, lets say that you wanted a <select> box language switcher that showed the current language while enabling the user to select the page in another. We'll also take this opportunity to demonstrate how you can retrieve the URL of another page using the $page->localUrl($language); function, which is an alternative to saving and changing the $user->language like we did in the previous example. Here is our desired output:And here is the code to produce it:<select onchange='window.location=$(this).val();'><?php foreach($languages as $language) { $selected = ''; // if this page isn't viewable (active) for the language, skip it if(!$page->viewable($language)) continue; // if language is current user's language, make it selected if($user->language->id == $language->id) $selected = " selected=selected"; // determine the "local" URL for this language $url = $page->localUrl($language); // output the option tag echo "<option$selected value='$url'>$language->title</option>"; } ?> </select>Using either one of these strategies, we can easily provide links for the user to switch to viewing the same page in another language.API additions and enhancements that accompany multi-language page namesIn the example above for the language switcher you might have noticed the localUrl($language) function that we used. This is a function that was added by Language Support Page Names, for your convenience. Here is a list of all the functions that are enhanced or added, should you ever find them helpful:$page->viewable($language);This function is always present in ProcessWire, but the Language Support Page Names module enhances it to be language aware. It returns whether the page is viewable by the current user in the given $language.$page->localUrl($language);Given a $language, this returns the URL for $page in that language.$page->localName($language);Given a $language, this returns the name for $page in that language.$page->localPath($language);Given a $language, this returns the path for $page in that language.Of course, these functions work on any Page object, we just use $page as an example.Working with pagination and/or URL segmentsPage numbers (pagination) and URL segments are fully supported by multi-language page names. You don't have to do anything other than you would without multi-language support. Meaning, you can simply enable these features from your template settings, and you are good to go.Multi-language page names does however add one nice feature for pagination: translated pagination URLs. Meaning, you can translate the keyword that signifies the current page number in the URL. Typically it is "page$n", where "$n" represents the current page number. But you can translate it specific to each language as needed. This is done in the Language Support Page Names module settings screen:Improving the multi-language UILanguage Field TabsYou might appreciate the UI improvements offered by the Language Field Tabs module, which places your multi-language fields in tabs, like shown in the screenshot below:Questions and supportPlease stop by our multi-langage support board in the ProcessWire forums and we'll be glad to help!Can multi-language page URLs be used with Form Builder and/or ProCache?Yes, both FormBuilder and ProCache are designed to work nicely with multi-language page URLs and multi-language support in general. All of your multi-language URLs are cachable by ProCache, except those requiring GET or POST form submissions. When creating multi-language forms with Form Builder, it will display the form in the appropriate language consistent with the language identified by the URL. Both ProCache and Form Builder are great additions to your multi-language site
- Add multi-language translations to your module: To add multi-language translations to your module, you can export a CSV file of translations, give them names that reflect the language and copy them to /languages/ directory in your module’s files. We'll cover the details in 4 steps below.Step 1: Locate and add your module’s PHP files to translateLocate the PHP files you want to translate from your admin: Setup > Languages > language > Site files > Find files to translate. Select the PHP file(s) in your module you want to translate and then submit the form. ProcessWire will generate new empty .json files for the files you selected to translate.Step 2: Translate your module’s files and then export to CSVIf you selected just one file above, it will take you there now. Otherwise, in Setup > Languages > language, click the "edit" link for file(s) added for your module. Once on the file translation screen, translate the text into the desired language and save. Near the top of the translation screen is a link to "Download" or "View" a CSV file of the translations. Click that to save (or view) the CSV file of translations.Step 3: Copy the CSV file(s) to a /languages/ dir in your moduleCopy the CSV file(s) or translations you exported in the previous step into a new /languages/ directory in your module’s files. For instance /site/modules/ProcessHello/languages/ is the one you'll see with the ProcessHello module.While not required, you might consider naming your files with the ISO-639-1 language code. For instance, German would be de.csv, Spanish would be es.csv, Finnish would be fi.csv, etc. Regardless of what name you use, the goal is just simply that the filename should explain what language it is for.A single CSV file can provide translations for multiple PHP files. So if your module happens to have multiple translatable files, you can bundle all the translations into a single CSV file (just copy and paste into one), or if need be, you can have multiple CSV files for each language. Though I prefer to keep it simple with one file per language.Step 4: Tell the user how to install your translationsIn your module’s documentation, instruct the user to install translations from your module’s info/config screen. It’s in the “Module Information” fieldset “Languages” row, where there is an “install translations” link. When new versions of your module update the translations, make note of that in your module's CHANGELOG.md file so that users will know to click the “install translations” again to update the translations.How users can install a module’s translationsThis is best demonstrated with a couple of screenshots. Below is a module’s configuration screen with the “Module Information” fieldset opened:Note the second to last row in the “Module Information” fieldset above where it says “Languages”, followed by a list of languages it contains translations for. When you click the “install translations” link you are taken to this screen:From here you can match the available translations with the languages you have installed on your site. In my case, I was able to match the “es” (Spanish) translation of the module with the Spanish version of the site. Once you click the Submit button, ProcessWire imports the translations and they take effect immediately.See also:Why use CSV for bundled translations?HelloWorld module with multi-language examplesProcessHello module with multi-language examples
