# Templates, Fields & Output Primer

Source: https://processwire.com/docs/start/structure/pages/
Source: https://processwire.com/docs/start/structure/templates/
Source: https://processwire.com/docs/start/structure/fields/
Source: https://processwire.com/docs/front-end/output/

## Core Concepts

- Pages: Almost everything in ProcessWire is represented by a Page. The term “Page” refers to a webpage, though in ProcessWire it’s also much more. What is a Page?Page typesPage family treePage bucketsPages can reference one anotherAlmost everything in ProcessWire is a PagePage scalabilityWhat is a Page?Page is the primarily type used in ProcessWire, representing everything from the pages on your website to the users that access it. But there's nothing complex about a Page, in fact, it's really very simple.A webpage has a dedicated URL that you can type in your web browser and view. That accurately describes a ProcessWire Page too. A webpage usually has content, so does a Page in ProcessWire. Though in ProcessWire, a Page is not just something for the browser to load or the eyes to look at. It is a dedicated location with a unique URL where content is stored, whether visible to the browser or not.A Page in ProcessWire can be used to output content like a webpage, but it can also be used as a more general storage location for content. Whether it produces output at its dedicated URL or not is up to the web developer.In a standard ProcessWire installation, most pages are both a visible webpage on the front-end, and a storage container for content on the back-end. Very often the content that is stored with the Page is the same content that is output at its dedicated URL on the front-end. Though as we'll find out below, the utility of pages goes far beyond that.Page typesWhat content is stored on any given Page depends on what fields the Page contains. These fields are dictated by the Page's template. The template in essence defines the Page's type. Without a template to define the Page's type, a Page would just be an abstract empty container with no content (which we refer to as a NullPage).The important thing to remember for now is simply that every page has one or more fields defined by the template that it uses. We commonly refer to pages by their template. For instance, we might refer to a Page using the “blog-post” template as a “Blog post”, rather than just a Page.Page family treeAll the pages in a ProcessWire installation exist within a family tree structure. Every Page has a parent Page (except the homepage), and every page can optionally have children. The homepage is the root of the family tree and it has children that are the first level of descendants in that family tree. Those descendants can have their own children, and so on.This family tree structure is consistent with the structure of URLs, where the URL “/” would be the homepage, and the URL “/about/” would be a child of the homepage. The URL “/about/staff/” would be a child of the “/about/” page, which also makes it a grandchild of the homepage.ProcessWire’s API uses methods that are consistent with this family tree structure, so every Page has “parent” and “children” properties/methods that you can access, among several others.Perhaps your parents have defined some aspects of your life. The same goes for pages—any parent Page can define what default order its children (which are also pages) should appear in. This order can be based on any field present in each child Page's content (like a date or title), or it can be a manual order that an editor drags and drops them to.Page bucketsWhile all pages exist within a family tree structure, that's not the only way that pages can be referenced. Pages can be identified and/or loaded based on any property common to them, regardless of where they are in the family tree.It's common for the Page template to be used as the property used to find all pages of the same type, wherever they may be. Though it can actually be any property/field common to any group of pages, anywhere in the family tree. In this manner, pages can work like the “bucket system”.To use a metaphor, think of an outdoor family gathering where everyone that's getting hot is encouraged to jump into the pool for a swim to cool off. That would be our “bucket” of “people that were getting hot and wanted to cool off”. Who is in this bucket (a pool) has everything to do with properties of the people (those getting hot), and nothing to do with parent and child relationships.In ProcessWire, we might ask for a bucket of pages that contains “all product pages” (all pages using the “product” template). Or we might ask for all product pages that also have a price less than 100 Euros. Or we might ask for all that, but the pages must also have a description that includes the word “Apple” somewhere within their description. In ProcessWire, the “bucket” is called a PageArray, which is a unique group of pages that can exist at runtime outside of the family tree structure.In this manner, ProcessWire can behave as a dynamic bucket system, where everything is findable, filterable and sortable, regardless of the underlying family tree structure in the website. The entire site's content is at your fingertips. Any one Page can access any others, just as if they were already present in memory.Pages can reference one anotherAnother highly useful aspect of Pages is that they can cross reference each other in one-to-many, many-to-one, or many-to-many relationships, regardless of where they are in the family tree structure. We call these Page references.A common example of Page references are categories, like those you might use to identify the topics for a blog post. Every blog post can have one or more of these selected to categorize it among other blog posts. For instance, there might be a category named “videos” that you'd select for all blog posts that have an embedded video. A user can click that category to view all posts that contain videos, regardless of dates or whatever else might be organizing the blog posts.Almost everything in ProcessWire is a PageSince every Page can have a defined type (template), the utility of Pages goes far beyond just your website content. It's also what ProcessWire uses to represent individual users, roles, permissions, languages, and more. In addition, they represent every Page in ProcessWire's admin, which is itself a website built in ProcessWire.The benefit of everything being a Page is that this keeps the both the admin UI and the API very simple. Once you know how to work with a Page, you know much of what's needed to work with any other type in ProcessWire. This results in clean consistency with how you work in ProcessWire, whether it's from the API or from the admin UI.Page scalabilityThere is no hard limit to the number of pages you can have in ProcessWire, and they are designed to scale infinitely, within the limits of the database. A given page might be packed with fields, content and files, or it might only have a simple title field. Pages are highly flexible and likely to be your best choice for managing content, no matter how much or little is needed on any given Page.As scale increases, ProcessWire is ready-to-go with pagination of pages, lazy-loading pages, load-on-demand fields/content, caching of page loads and output, and more. ProcessWire is built with the assumption that your scale is large, regardless of how small or large it actually is, so that there is a quality, consistency and ease-of-use that transcends scale.
- Templates: Every Page has a template which defines the type of Page and what fields are present on pages using it. Every template may be used by one or more pages.What is a template?Template filesExamples of templatesScalability and customizabilityOther Page settings managed by templatesWhat is a template?Each Page in ProcessWire is a storage container for content, and each Page also has a map for the structure of that content, called the “template.” The primary role of these templates is to define what fields are present on pages using them, but they also do much more.We refer to the template when talking about the type of a Page. For example, a template called “product” might represent a product being sold that has a title, description and price. Every page that uses the "product" template would represent a single product having the ability to store each of those fields (title, description, price). When a Page uses the "product" template, we would refer to it as a “Product Page”, since the template defines the type of Page that it is.If you are familiar with databases, you can think of the template as the database table that defines the fields for each row (schema), while each Page is one of those rows. While this isn't actually how ProcessWire maps pages and tables to the database, it can be a helpful metaphor in this case.Template filesEach template may also be represented with a PHP file in the /site/templates/ directory of a ProcessWire installation. Each template file is responsible for handling the output of pages that use the corresponding template. To repeat our earlier example, the “product” template would be represented by a file named /site/templates/product.php. That file could output the title, description and price of any product.Template files are only required for pages that must produce output when accessed at their URL. Without a template file to output a Page's content, there's nothing to output, so ProcessWire will produce a "404 page not found" error if the URL is accessed from the browser, regardless of whether a Page actually exists at that URL.Even in a default installation, many pages in ProcessWire have no template file. For instance, users, roles and permissions have no corresponding template file by default. That's because those Page types are used for access control, and we don't need or want them to produce any output.Examples of templatesEarlier we used an example of a “product” template, but let’s look at more common examples. It's common in websites to have a template named "home" to represent the homepage, and another called "basic-page" to represent basic content pages, like those you might use in an “About Us” section. These templates will always have corresponding home.php and basic-page.php template files to handle their output.If the site has a blog, we might have a template named “blog-post” to represent each post in the blog section of the site. If our site as a search engine or contact page, we'll likely use separate templates for those as well, as their content and/or implementation needs are likely to be unique relative to other pages in the site. For instance, our "search" template needs to have a template file (search.php) that takes user input and uses it to search on our content, then output links to the matching pages.Scalability and customizabilityYou can create as many templates as you need, and there is no limit to the number of pages you can create using any given template. Likewise, you can assign as many fields as you need to any template. This means the possibilities are endless in terms of custom content types and scalability. ProcessWire makes no assumptions about what your needs are and thus, all content types are custom content types.Needs change over time, and templates are built for this. You can add or remove fields from your template at any time. Those changes are immediately reflected upon any any pages using the template.Other Page settings managed by templatesThe primarily role of a template is to represent a Page's type, defining the fields of pages using it. But templates also define a lot more about the page, when and where needed:Access controlA template can define access control for pages using it. This is used to limit what roles can view, edit, move or delete pages using the template, what roles are allowed to create new pages of that type, and what roles are allowed add new child pages to them. The template can also dictate whether or not that access control gets inherited by its children, grandchildren, and so on.FamilyA template can dictate whether or not pages using it support children, as well as what templates are allowed for those children. Likewise, a template can indicate whether it is allowed to be used for new pages, and if so, where those pages can be created.URLsA template defines the style of URLs used by pages using it, and whether those URLs support pagination, URL segments, trailing slashes, and more. It can also dictate whether pages using it may only be accessed by HTTPS.FilesIf a template has a corresponding template file, it can indicate what its content-type will be on the front-end, whether that is HTML, XML, JSON, plain text, or any other user definable content-type. It can also indicate any other file that should be automatically prepended or appended to its output.CacheA template can be configured to cache its output on the front-end, so that it only reloads its PHP template-file at certain intervals, and delivers cached content the rest of the time. Several other settings accompany the details of how the caching should work.AdvancedA template can be categorized with tags, it can customize the page editor (when an edited page is using the template), it can dictate how required fields are handled, it can control how using it appear in the page list, and more.
- Fields: Fields in ProcessWire are where the content is actually stored. Any field may be one of many storing content for a Page and its output.What are fields?Defining a field’s type (Fieldtype)Collecting input for a field (Inputfield)Fieldtypes and Inputfields are plugin modulesWhat are fields?Fields store a single type of content. For instance, a base ProcessWire installation has a field named "title" that contains the Title of each Page. Thus there is one Title field per Page. Most ProcessWire installations also have a field called "body" which stores the multi-line Body Copy of a Page.These fields are defined in ProcessWire, and every installation can have a different set of fields. The relevant fields are added to each template in whatever combination and order the site developer chooses. A given field can be added to one or more templates, so fields are reusable across templates.When one goes to edit a Page, they see inputs only for the fields that are present on the Page's template. Fields can easily be added or removed from a template as needs change over time.Defining a field’s type (Fieldtype)Every field has a type, which is referred to as the Fieldtype (1 word). This Fieldtype indicates the type of content that the field is storing. In many cases, the names of the simpler Fieldtypes line up with the names of the HTML inputs they loosely represent. For instance, a multi-line text field would be of type “Textarea”, while a single-line text field would have type of “Text”.Collecting input for a field (Inputfield)Every field in ProcessWire is defined by its Fieldtype, but the Fieldtype doesn't handle the actual input for that field. This is handled instead by the Inputfield (1 word). An Inputfield actually renders the HTML needed to present an input to the user in a form, and then it handles the processing of that input when the form is submitted.Most of the time, the Fieldtype defines what type of Inputfield it requires to collect input for it, so you don't often have to consider it. Though in some cases a Fieldtype will let you select the Inputfield. For instance, the Textarea Fieldtype will let you choose either a regular Textarea, or a Rich-Text Editor (i.e. CKEditor) for input.Fieldtypes and Inputfields are plugin modulesOne thing that makes fields really flexible is that each Fieldtype and Inputfield is actually a type of plugin/module. The ProcessWire core comes with more than a dozen of them, which cover the most common needs. But any number of additional Fieldtype and/or Inputfield modules can be installed as modules, enabling you to store all kinds of different types of content. Many third party Fieldtype modules come with their own Inputfield modules and are installed together.FlexibilityGiven that ProcessWire can have any number of pages, any number of custom content types (templates), any number of fields, and any number of field types and inputs, that makes it extremely flexible to handle just about any content management need.

## Output Strategies

Template files receive content and how they deliver it to the user is what we call the output strategy. There are a few different options and this section covers each in detail.Direct outputYou already know direct output because it simply means printing output directly, as you might do in any other PHP script.Learn more →Delayed outputDelayed output focuses on rendering the content/markup for all the various regions of our final document ahead of time, but…Learn more →Markup regionsMarkup regions give you the best of both worlds—the simplicity of direct output with the power of delayed output, just using HTML.Learn more →
